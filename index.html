<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>재무제표 기반 AI 기업 진단</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap');

        body {
            font-family: 'Noto Sans KR', sans-serif;
        }

        .print-only {
            display: none;
        }

        /* [NEW] 리포트 결과 화면/인쇄 공통 타이포그래피 */
        .report-view .report-info-label {
            font-size: 8.5pt !important;
        }

        .report-view .ai-text-header {
            font-size: 13pt !important;
            margin-top: 5mm !important;
            margin-bottom: 2mm !important;
        }

        /* [Screen Styles] 화면용 */
        @media screen {
            .report-view .report-info-value {
                font-size: 11pt !important;
            }

            .report-view .ai-text-line {
                font-size: 12pt !important;
                /* 화면 본문 키움 (11.5 -> 12) */
                line-height: 1.7 !important;
            }

            .ai-text-spacer {
                height: 4px;
                /* 화면에서는 h-1(4px) 유지 */
            }

            /* 화면 시 섹션 제목 간격 조정 (제목과 본문 사이 줄임) */
            .report-view .ai-text-header {
                font-size: 13.5pt !important;
                margin-top: 24px !important;
                margin-bottom: 4px !important;
                /* 2mm(약 8px) -> 4px 로 축소 */
            }
        }

        /* [Print Styles] 인쇄용 (화면보다 작게, 간격 최소화) */
        @media print {
            .report-view .report-info-value {
                font-size: 10pt !important;
            }

            .report-view .ai-text-line {
                font-size: 11.5pt !important;
                line-height: 1.6 !important;
                margin-bottom: 0 !important;
                /* 줄 간격 제거 */
            }

            /* 인쇄 시 섹션 제목 간격 최적화 (섹션 간 간격 확보, 본문과는 밀착) */
            .report-view .ai-text-header {
                font-size: 13pt !important;
                margin-top: 7mm !important;
                /* 3mm -> 7mm (이전 섹션과 거리 늘림) */
                margin-bottom: 0.5mm !important;
                /* 1mm -> 0.5mm (본문과 거리 줄임) */
                padding-bottom: 0 !important;
                border-bottom-width: 0.5px !important;
            }

            /* 인쇄 시 문단 간격 최소화 */
            .ai-text-spacer {
                height: 0px !important;
                /* 1px -> 0px */
                margin: 0 !important;
                padding: 0 !important;
                display: block !important;
                border: none !important;
            }
        }

        .ai-text-header {
            font-size: 1.1rem;
            font-weight: 900;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            color: #1e293b;
            border-bottom: 1px dashed #cbd5e1;
            padding-bottom: 0.25rem;
        }

        /* [중요] 통합버전18의 인쇄 설정 100% 원복 (입력 페이지 인쇄 보존용) */
        @media print {
            @page {
                size: A4;
                margin: 0;
            }

            /* [NEW] 리포트 전용 페이지 설정 (매 페이지 동일한 상단 여백 확보) */
            @page report-fmt {
                size: A4;
                margin: 20mm 10mm 10mm 10mm;
                /* 상단 20mm, 하좌우 10mm */
            }

            .no-print {
                display: none !important;
            }

            .print-only {
                display: inline !important;
            }

            .screen-only {
                display: none !important;
            }

            body {
                padding: 0 !important;
                background: white !important;
                font-size: 8.5pt !important;
                line-height: 1.15 !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
                align-items: center !important;
                width: 210mm !important;
                margin: 0 !important;
            }

            /* 설문지 인쇄: 1페이지 고정 */
            body:has(.print-container:not(.report-view)) {
                height: 297mm !important;
            }

            /* 리포트 인쇄: 다중 페이지 허용 */
            body:has(.report-view) {
                height: auto !important;
                display: block !important;
                width: 100% !important;
                /* @page margin 내에서 꽉 차게 */
                padding: 0 !important;
            }

            .print-container {
                box-shadow: none !important;
                border: 2pt solid #000 !important;
                width: 190mm !important;
                margin: 0 auto !important;
                padding: 0 !important;
                border-radius: 0 !important;
                background: white !important;
                display: flex;
                flex-direction: column;
                transform: translateY(10mm) !important;
                box-sizing: border-box !important;
            }

            /* 리포트 화면 전용 인쇄 스타일 (A4 2페이지 허용) */
            /* print-container 속성을 완전히 덮어써서 리포트용으로 재설정 */
            .report-view.print-container {
                page: report-fmt !important;
                /* 위에서 정의한 페이지 여백 적용 */
                transform: none !important;
                /* border: none !으로 변경하여 테두리 제거 (영역만 유지) */
                border: none !important;
                width: 100% !important;
                /* 페이지 여백 제외한 영역 꽉 채움 (190mm 효과) */
                margin: 0 !important;
                /* @page가 여백 10mm를 담당하므로 추가 여백 없음 */
                padding: 0mm 5mm !important;
                /* 상하 패딩 제거하여 1,2페이지 동일 시작점 확보, 좌우만 유지 */
                box-sizing: border-box !important;
                min-height: auto !important;
                /* 최소 높이 확보 */

                /* [핵심] 페이지가 나뉠 때 테두리 복제 (각 페이지마다 테두리 그려짐) -> 테두리 없으므로 패딩 복제용 */
                -webkit-box-decoration-break: clone !important;
                box-decoration-break: clone !important;
            }

            /* [수정] 리포트 제목 상단 여백 제거 (1페이지 상단 여백을 @page 설정에만 의존하게 함) */
            .report-view h1 {
                margin-top: 0 !important;
                padding-top: 0 !important;
            }

            .report-view .border-b-4 {
                padding-top: 0 !important;
                margin-top: 0 !important;
            }

            .p-10 {
                padding: 0.5rem 1rem !important;
            }

            h1 {
                font-size: 16pt !important;
                margin-bottom: 0.05rem !important;
            }

            .text-sm {
                font-size: 7.5pt !important;
            }

            .text-xl {
                font-size: 10.5pt !important;
            }

            .p-10.space-y-12 {
                padding: 0.6rem 1.2rem !important;
            }

            .space-y-12>*+* {
                margin-top: 1.1rem !important;
            }

            h2 {
                font-size: 10.5pt !important;
                margin-bottom: 0 !important;
            }

            .mb-6,
            .mb-4 {
                margin-bottom: 0.3rem !important;
            }

            .w-1\.5.h-6 {
                height: 1rem !important;
                width: 4px !important;
                background-color: #0055A5 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            .info-grid {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 0.6rem !important;
            }

            .info-grid label {
                font-size: 8pt !important;
            }

            .info-grid select,
            .info-grid input {
                padding: 0.2rem 0.4rem !important;
                font-size: 8.5pt !important;
                height: 26px !important;
                border: 0.5pt solid #ccc !important;
            }

            .revenue-box {
                margin-top: 0.5rem !important;
                padding: 0.4rem 0.8rem !important;
                gap: 0.6rem !important;
                flex-wrap: nowrap !important;
                justify-content: space-between !important;
            }

            .revenue-box span {
                font-size: 7.5pt !important;
            }

            .revenue-box input {
                width: 70px !important;
                padding: 0.2rem 0.3rem !important;
                font-size: 7.5pt !important;
            }

            .revenue-box label {
                gap: 0.2rem !important;
            }

            .revenue-box input[type="radio"] {
                width: 12px !important;
                height: 12px !important;
            }


            table th,
            table td {
                padding: 0.4rem 0.4rem !important;
                font-size: 9pt !important;
                border: 0.5pt solid #eee !important;
            }

            .text-center-print {
                text-align: center !important;
            }

            .w-9.h-9 {
                width: 1.2rem !important;
                height: 1.2rem !important;
                font-size: 8pt !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            .bottom-grid {
                display: grid !important;
                grid-template-columns: 1.1fr 0.9fr !important;
                gap: 1.2rem !important;
                align-items: stretch !important;
            }

            .benefit-grid {
                display: grid !important;
                grid-template-columns: 1fr 1fr !important;
                gap: 0.35rem !important;
                width: 100% !important;
            }

            .benefit-grid label {
                padding: 0.3rem 0.5rem !important;
                border: 0.5pt solid #eee !important;
                font-size: 8pt !important;
                height: 32px !important;
                display: flex !important;
                align-items: center;
                width: 100% !important;
                box-sizing: border-box !important;
                margin: 0 !important;
            }

            .notes-area {
                min-height: 132px !important;
                height: 100% !important;
                font-size: 9pt !important;
                padding: 0.5rem !important;
                border: 0.5pt solid #ccc !important;
                box-sizing: border-box !important;
            }

            /* --- [추가] 리포트 결과 화면 전용 스타일 --- */
            .report-view {
                display: block !important;
                box-shadow: none !important;
            }

            /* 기본정보 요약 그리드 (Compact) */
            .report-info-container {
                border: 1pt solid #ccc !important;
                background-color: #f8fafc !important;
                padding: 3mm !important;
                margin-bottom: 4mm !important;
                border-radius: 4px !important;
            }

            .report-info-grid {
                display: grid !important;
                grid-template-columns: repeat(4, 1fr) !important;
                gap: 2mm !important;
                row-gap: 2mm !important;
            }

            .report-info-item {
                display: flex !important;
                flex-direction: column !important;
            }

            .report-info-label {
                font-size: 7.5pt !important;
                color: #64748b !important;
                margin-bottom: 0 !important;
                font-weight: bold !important;
            }

            .report-info-value {
                font-size: 10pt !important;
                font-weight: 800 !important;
                color: #000 !important;
            }

            /* AI 텍스트 (A4 2페이지 분량) */
            /* AI 텍스트 (A4 2페이지 분량) */
            .ai-text-line {
                font-size: 10.5pt !important;
                line-height: 1.6 !important;
                /* margin-bottom 제거 (상단 @media print 덮어쓰기 방지) */
                text-align: justify !important;
            }

            .ai-text-header {
                font-size: 11.5pt !important;
                font-weight: 900 !important;
                /* margin 제거 (상단 @media print 덮어쓰기 방지) */
                color: #000 !important;
                display: block;
            }

            .ai-text-bold {
                font-weight: 700 !important;
            }

            /* AI 리포트 테이블 스타일 */
            .ai-table {
                width: 100%;
                border-collapse: collapse;
                margin: 10px 0 20px 0;
                font-size: 13px;
                border: 1px solid #cbd5e1;
            }

            .ai-table th {
                background-color: #f1f5f9;
                border: 1px solid #cbd5e1;
                padding: 8px 12px;
                font-weight: 800;
                color: #1e293b;
                text-align: center;
                white-space: nowrap;
            }

            .ai-table td {
                border: 1px solid #cbd5e1;
                padding: 8px 12px;
                color: #334155;
                vertical-align: middle;
            }

            .ai-table tr:nth-child(even) {
                background-color: #fcfcfc;
            }
        }
    </style>
</head>

<body class="bg-slate-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // [수정] 정적 아이콘 정의 (Lucide 의존성 제거 및 DOM 충돌 방지)
        const ICON_PATHS = {
            "shield-check": "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z M9 12l2 2 4-4",
            "upload-cloud": "M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242 M12 12v9 M16 16l-4-4-4 4",
            "file-text": "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z M14 2v6h6 M16 13H8 M16 17H8 M10 9H8",
            "file": "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z M14 2v6h6",
            "rotate-ccw": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12 M3 3v9h9",
            "search": "M21 21l-6-6m2-5a7 7 0 1 1-14 0 7 7 0 0 1 14 0z",
            "loader-2": "M21 12a9 9 0 1 1-6.219-8.56"
        };

        const Icon = ({ name, size = 18, className = "" }) => {
            const path = ICON_PATHS[name] || "";
            return (
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width={size}
                    height={size}
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className={className}
                >
                    {path.includes("M") && path.split(' M').map((d, i) => (
                        <path key={i} d={i === 0 ? d : 'M' + d} />
                    ))}
                </svg>
            );
        };

        const App = () => {
            const currentYear = new Date().getFullYear();

            const [apiKey, setApiKey] = useState(localStorage.getItem('gemini_api_key') || '');
            const [groqApiKey, setGroqApiKey] = useState(localStorage.getItem('groq_api_key') || '');
            const [selectedModel, setSelectedModel] = useState(localStorage.getItem('selected_model') || 'gemini-3-flash');
            const [groqModelId, setGroqModelId] = useState(''); // [추가] 동적 감지된 Groq 모델 ID
            const [showApiConfig, setShowApiConfig] = useState(false);
            const [viewMode, setViewMode] = useState('form');
            const [isAnalyzing, setIsAnalyzing] = useState(false);
            const [analysisStatus, setAnalysisStatus] = useState('');
            const [aiResponse, setAiResponse] = useState('');

            // 입력 데이터 상태
            const [formData, setFormData] = useState({
                businessNumber: '',
                industry: '',
                foundationDate: '',
                majorProducts: '',
                financialFile: null
            });
            const [filePreview, setFilePreview] = useState(null);

            useEffect(() => { localStorage.setItem('gemini_api_key', apiKey); }, [apiKey]);
            useEffect(() => { localStorage.setItem('groq_api_key', groqApiKey); }, [groqApiKey]);
            useEffect(() => { localStorage.setItem('selected_model', selectedModel); }, [selectedModel]);

            // [추가] Groq 모델 동적 탐색 (vision 지원 모델 찾기)
            useEffect(() => {
                if (!groqApiKey) return;
                const checkGroqModel = async () => {
                    try {
                        const res = await fetch('https://api.groq.com/openai/v1/models', {
                            headers: { Authorization: `Bearer ${groqApiKey}` }
                        });
                        const data = await res.json();
                        if (data && data.data) {
                            // [수정] 사용자의 요청으로 'Llama 4 Maverick' 모델만 탐색
                            const maverick = data.data.find(m => m.id.includes('maverick') || m.id.includes('llama-4'));

                            if (maverick) {
                                console.log('Detected Groq Maverick Model:', maverick.id);
                                setGroqModelId(maverick.id);
                            } else {
                                console.warn('Maverick model not found.');
                                setGroqModelId(''); // 찾지 못하면 비워둠 (에러 처리를 위함)
                            }
                        }
                    } catch (e) {
                        console.error("Groq model check failed:", e);
                    }
                };
                checkGroqModel();
            }, [groqApiKey]);

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setFormData({ ...formData, financialFile: file });
                    // [수정] 미리보기 생성하지 않음 (파일명만 표시)
                }
            };

            // [수정] 텍스트 포매터: 줄간격 최적화
            // [수정] 텍스트 포매터: 마크다운 테이블 지원 추가
            const formatText = (text) => {
                if (!text) return "";
                // [수정] 텍스트 전처리: [성장성], [수익성], [안정성] 앞에는 강제로 줄바꿈 2번 추가하여 문단 분리 보장
                // AI가 한 줄에 이어서 출력하거나 줄바꿈을 안 했을 경우를 대비함
                text = text.replace(/(\[수익성\])/g, '\n\n$1').replace(/(\[안정성\])/g, '\n\n$1').replace(/(\[성장성\])/g, '\n\n$1');

                const lines = text.split('\n');
                const elements = [];
                let tableBuffer = [];
                let inTable = false;

                const renderTable = (rows, keyPrefix) => {
                    if (rows.length < 2) return null; // 최소 헤더 + 구분선 필요

                    // 헤더 파싱
                    const headers = rows[0].split('|').map(h => h.trim()).filter(h => h);
                    // 데이터 파싱 (구분선 --- 제외)
                    const dataRows = rows.slice(2).map(row =>
                        row.split('|').map(c => c.trim()).filter((c, i) => i < headers.length + 1 && c !== '') // 빈 앞뒤 파이프 처리
                    );

                    return (
                        <div key={keyPrefix} className="overflow-x-auto">
                            <table className="ai-table">
                                <thead>
                                    <tr>
                                        {headers.map((h, i) => <th key={i}>{h}</th>)}
                                    </tr>
                                </thead>
                                <tbody>
                                    {dataRows.map((row, i) => (
                                        <tr key={i}>
                                            {row.map((cell, j) => <td key={j} dangerouslySetInnerHTML={{ __html: cell.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>') }} />)}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    );
                };

                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();

                    // [수정] 소제목([성장성]등) 처리 로직 강화
                    if (line.includes('[성장성]') || line.includes('[수익성]') || line.includes('[안정성]')) {
                        // 1. 기존 모든 볼드체(**) 및 헤더(###) 제거하여 베이스 텍스트 추출 (강제 초기화)
                        let cleanLine = line.replace(/^[#\s]+/, '').replace(/\*\*/g, '').trim();

                        // 2. 소제목만 추출 (대괄호 포함)
                        const tagMatch = cleanLine.match(/\[(성장성|수익성|안정성)\]/);
                        if (tagMatch) {
                            const tag = tagMatch[0];
                            const content = cleanLine.replace(tag, '').trim();
                            // 3. 소제목은 볼드체로, 내용은 일반체로 재조합
                            line = `**${tag}** ${content}`;
                        } else {
                            line = cleanLine;
                        }

                        // 4. 다음 줄이 있고 텍스트가 있으면 합침 (기존 로직 유지)
                        if (line.length < 50 && i + 1 < lines.length && lines[i + 1].trim() !== '') {
                            line = line + ' ' + lines[i + 1].trim().replace(/\*\*/g, ''); // 다음 줄에서도 볼드 제거
                            i++;
                        }
                    }

                    // 테이블 감지 (파이프 | 로 시작)
                    if (line.startsWith('|')) {
                        inTable = true;
                        tableBuffer.push(line);
                        continue;
                    }

                    if (inTable) {
                        inTable = false;
                        elements.push(renderTable(tableBuffer, `table-${i}`));
                        tableBuffer = [];
                    }

                    // 일반 텍스트 처리
                    // --- 구분선, *** 구분선 제거
                    if (line.match(/^[-*=_]{3,}$/)) continue;

                    // 빈 줄은 스페이서
                    if (!line) {
                        elements.push(<div key={i} className="ai-text-spacer"></div>);
                        continue;
                    }

                    // 헤더 인식 (짧은 제목 형태만 헤더로 인정)
                    // [수정] [성장성/수익성/안정성] 등 대괄호로 시작하는 소제목은 헤더로 인식하지 않도록 예외 처리
                    if (line.match(/^(##|#|\*\*?\s*[1-5]\.|[1-5]\.)/) && !line.includes('[성장성]') && !line.includes('[수익성]') && !line.includes('[안정성]')) {
                        // 텍스트 길이가 100자 미만인 경우만 헤더로 처리 (본문이 1.로 시작하는 경우 방지)
                        if (line.length < 100) {
                            const cleanLine = line.replace(/^#+\s*/g, '')
                                .replace(/\*\*/g, '')
                                .replace(/\s*\([^)]*(?:분량|이내)[^)]*\)/g, '') // (분량 엄수: 500자 이내) 같은 텍스트 제거
                                .trim();
                            elements.push(<div key={i} className="ai-text-header">{cleanLine}</div>);
                            continue;
                        }
                    }

                    // 본문 (볼드체 처리)
                    // [수정] 볼드체 파싱 후, 남은 일반 텍스트에서 ** 마크다운 문법 제거 (사용자 요청)
                    const parts = line.split(/(\*\*.*?\*\*)/g);
                    elements.push(
                        <div key={i} className="ai-text-line">
                            {parts.map((part, j) => {
                                if (part.startsWith('**') && part.endsWith('**')) {
                                    // 정상적인 볼드체 덩어리인 경우
                                    const content = part.slice(2, -2);
                                    if (!content) return null;
                                    return <strong key={j} className="ai-text-bold">{content}</strong>;
                                }
                                // 일반 텍스트인 경우: 마크다운 문법(**)이 남아있으면 제거
                                return <span key={j}>{part.replace(/\*\*/g, '')}</span>;
                            })}
                        </div>
                    );
                }

                // 마지막에 남아있는 테이블 처리
                if (inTable) {
                    elements.push(renderTable(tableBuffer, `table-end`));
                }

                return elements;
            };

            // 파일을 Base64로 변환하는 헬퍼 (다중 페이지 지원)
            const fileToGenerativePart = async (file, isGroq = false) => {
                // PDF 파일인 경우: Groq는 이미지 변환 필수, Gemini는 선택 (여기서는 Gemini도 이미지로 변환하지 않고 원본 PDF 사용하도록 분기 처리)
                if (file.type === 'application/pdf') {
                    // [수정] Gemini 모델인 경우 (isGroq === false), PDF 원본 그대로 반환
                    if (!isGroq) {
                        const base64EncodedDataPromise = new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result.split(',')[1]);
                            reader.readAsDataURL(file);
                        });
                        return [{
                            inlineData: { data: await base64EncodedDataPromise, mimeType: 'application/pdf' },
                        }];
                    }

                    // [Groq 전용] PDF를 이미지로 변환 (기존 로직 유지)
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        const parts = [];

                        // 최대 20페이지 변환 및 5장 제한 맞추기 (이미지 병합)
                        const maxPages = Math.min(pdf.numPages, 20);
                        const pagesPerImage = Math.ceil(maxPages / 5); // 5장 제한을 맞추기 위해 한 이미지에 들어갈 페이지 수 계산

                        console.log(`Processing PDF: ${maxPages} pages, merging ${pagesPerImage} pages per image`);

                        for (let i = 1; i <= maxPages; i += pagesPerImage) {
                            // 병합할 페이지 범위 결정
                            const endPage = Math.min(i + pagesPerImage - 1, maxPages);
                            const pagesToMerge = [];
                            let totalHeight = 0;
                            let maxWidth = 0;

                            // 해당 범위의 페이지들을 렌더링하고 크기 계산
                            for (let j = i; j <= endPage; j++) {
                                const page = await pdf.getPage(j);
                                // [수정] 스케일 1.0으로 조정 (1.5도 너무 커서 Vision 모델이 리사이징하며 하단부 텍스트가 잘리는 현상 방지)
                                // 1.0 (72dpi 기준)도 텍스트 인식에는 충분함
                                const viewport = page.getViewport({ scale: 1.0 });
                                pagesToMerge.push({ page, viewport });
                                totalHeight += viewport.height;
                                maxWidth = Math.max(maxWidth, viewport.width);
                            }

                            // [수정] 페이지 사이 구분선 높이 추가 (20px)
                            const separatorHeight = 20;
                            totalHeight += separatorHeight * (pagesToMerge.length - 1);

                            // 병합된 캔버스 생성
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.width = maxWidth;
                            canvas.height = totalHeight;

                            // [수정] 배경을 흰색으로 채우기 (JPEG 변환 시 투명 배경이 검게 변하는 현상 방지)
                            context.fillStyle = '#FFFFFF';
                            context.fillRect(0, 0, canvas.width, canvas.height);

                            // 페이지들을 캔버스에 순차적으로 그리기
                            let currentY = 0;
                            for (let k = 0; k < pagesToMerge.length; k++) {
                                const { page, viewport } = pagesToMerge[k];
                                // 중앙 정렬을 위한 x 좌표 계산 (혹은 0)
                                const x = (maxWidth - viewport.width) / 2;

                                // 안전하게 개별 캔버스에 그리고 복사하는 방식 사용
                                const tempCanvas = document.createElement('canvas');
                                tempCanvas.width = viewport.width;
                                tempCanvas.height = viewport.height;
                                await page.render({ canvasContext: tempCanvas.getContext('2d'), viewport }).promise;

                                context.drawImage(tempCanvas, x, currentY);
                                currentY += viewport.height;

                                // [추가] 페이지 사이 구분선 그리기 (마지막 페이지 제외)
                                if (k < pagesToMerge.length - 1) {
                                    context.fillStyle = '#E2E8F0'; // Slate-200 색상
                                    context.fillRect(0, currentY, maxWidth, separatorHeight);

                                    // [추가] "PAGE BREAK - CONTINUED" 워터마크 안내 텍스트 추가
                                    context.font = 'bold 10px sans-serif';
                                    context.fillStyle = '#94A3B8'; // Slate-400
                                    context.textAlign = 'center';
                                    context.fillText('PAGE BREAK - CONTINUED ↓', maxWidth / 2, currentY + (separatorHeight / 2) + 4);

                                    currentY += separatorHeight;
                                }
                            }

                            // 병합된 이미지 추가
                            const imageBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                            parts.push({
                                inlineData: { data: imageBase64, mimeType: 'image/jpeg' }
                            });
                        }

                        console.log(`PDF processed: ${maxPages} pages merged into ${parts.length} images`);
                        return parts;
                    } catch (e) {
                        console.error('PDF Conversion Failed:', e);
                        throw new Error('PDF 변환에 실패했습니다. 이미지 파일로 다시 시도해주세요.');
                    }
                }

                // 일반 이미지 파일 처리
                const base64EncodedDataPromise = new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.readAsDataURL(file);
                });
                return [{
                    inlineData: { data: await base64EncodedDataPromise, mimeType: file.type },
                }];
            };

            const runAnalysis = async () => {
                if (selectedModel.includes('gemini') && !apiKey) { alert('Safe Connect Mode에서 Google API Key를 먼저 입력해주세요.'); return; }
                if (selectedModel === 'groq' && !groqApiKey) { alert('Safe Connect Mode에서 Groq API Key를 먼저 입력해주세요.'); return; }
                if (!formData.financialFile) { alert('재무제표 파일을 업로드해주세요.'); return; }

                // [추가] Groq Vision 모델은 PDF 미지원 (JPG, PNG 등 이미지 파일만 가능)
                /* 
                // [제거] 내부 변환 로직 추가로 인해 차단 해제
                if (selectedModel === 'groq' && formData.financialFile.type === 'application/pdf') {
                    alert('Groq Vision 모델은 이미지 파일(JPG, PNG 등)만 지원합니다.\nPDF 파일은 Gemini 모델을 이용하거나, 이미지로 변환하여 업로드해주세요.');
                    return;
                } 
                */

                setIsAnalyzing(true);
                setIsAnalyzing(true);
                let displayModelName = selectedModel.includes('gemini') ? 'Gemini' : (groqModelId || 'Llama 4 Maverick');
                setAnalysisStatus(`${displayModelName} 모델이 리포트 작성 중...`);

                try {
                    // [수정] 모델에 따라 PDF 처리 방식 분기 (Groq일 때만 true 전달)
                    const isGroq = (selectedModel === 'groq');
                    const fileParts = await fileToGenerativePart(formData.financialFile, isGroq);

                    // [추가] 사용자 안심을 위한 상세 진행상황 표시
                    if (formData.financialFile.type === 'application/pdf' && isGroq) {
                        // fileToGenerativePart에서 반환된 parts 길이는 이미지 수 (페이지 수가 아님)
                        // 정확한 페이지 수는 fileToGenerativePart 내부 로그로만 확인 가능하나, 
                        // 여기서는 "PDF 문서 전체 스캔 완료" 메시지로 대체
                        setAnalysisStatus(`${displayModelName} 모델이 PDF 변환 후 리포트 작성 중...`);
                    } else if (formData.financialFile.type === 'application/pdf' && !isGroq) {
                        setAnalysisStatus(`${displayModelName} 모델이 PDF 원본 분석 및 리포트 작성 중...`);
                    }

                    const promptText = `
당신은 서울신용보증재단의 기업 재무 분석 전문가이자 베테랑 대출 심사역입니다.
제공된 '업체 정보'와 '재무제표'를 바탕으로 심층적인 기업 진단 리포트를 작성하세요.

**[참고: 식별정보 마스킹]**
제공되는 재무제표 이미지는 개인정보보호를 위해 업체명, 사업자번호, 대표자명 등 주요 식별정보가 **마스킹 처리**되어 있을 수 있습니다.
이는 의도된 보안 조치이므로, 식별정보 누락을 "분식회계 의심"이나 "자료 미비"로 간주하지 마십시오.
대신, 입력된 '업체 개요' 정보를 해당 기업의 신원 정보로 신뢰하고 분석을 진행하십시오.

**[이미지 처리 및 데이터 추출 지침 - 필독]**
1. **전수 조사 원칙**: 
   - 제공된 이미지는 여러 페이지가 수직으로 병합된 형태입니다. 상단(1페이지)부터 하단(마지막 페이지)까지 **단 하나의 표나 숫자도 놓치지 말고 순차적으로 정밀 스캔**하세요.
   - 특히 이미지 하단부에 위치한 과거 연도(예: 3년 전 데이터)가 잘리거나 누락되지 않도록 끝까지 읽어야 합니다.

2. **연도별 데이터 매핑**:
   - 재무상태표와 손익계산서에서 확인되는 **모든 연도(제N기, 제N-1기, 제N-2기 등)**를 먼저 리스트업한 뒤 분석을 시작하세요.
   - 특정 연도의 데이터가 부족해 보인다면, 이미지의 다른 섹션(예: 표준재무제표와 비교식 재무제표의 교차 확인)에서 해당 수치를 반드시 찾아내어 보완하세요.

3. **중간 요약 금지 (No Early Exit)**:
   - "데이터가 방대하여 일부만 분석함"과 같은 임의적인 판단을 절대 금지합니다. 
   - 텍스트를 짧게 끊지 말고, 각 섹션별로 요구된 분량을 최대한 활용하여 심층적으로 기술하세요.

4. **시각적 구분선 인지**: 
   - 페이지 사이의 회색 구분선(Separator Bar)은 문서가 끊긴 것이 아니라 **'다음 페이지로 이어짐'**을 의미합니다. 이를 인지하고 문맥을 끊김 없이 연결하여 해석하세요.
   - **"데이터가 누락되면 보고서 전체의 신뢰도가 깨진다"**는 점을 강력히 인지하고 정밀 판독하세요.

**[필수 확인: 분석 대상 데이터 검증 및 해석]**
- 분석을 시작하기 전에, 제공된 재무제표 이미지에서 **확인 가능한 모든 재무 보고서의 연도**와 **문서 제목**을 찾아내세요.
- **[매우 중요 - 데이터 동등 취급]**: **'표준제무제표'**와 **'비교식 재무제표'**는 양식이 다를 뿐, 모두 **동등한 분석 대상(Primary Data)**입니다.
    - 예를 들어 2022년은 표준재무제표이고, 2023-2024년은 비교식 재무상태표라면, **"2022년부터 2024년까지의 재무제표를 분석했다"**고 서술해야 합니다.
    - 2022년 자료를 **"참고 자료"**나 **"부수적인 자료"**로 취급하여 **분석에서 배제하거나 중요도를 낮추지 마세요.**
- **[매우 중요]** "1. 재무제표 리뷰" 섹션 서두에 **실제 발견된** 연도와 문서 종류를 명시해 주세요. (예: "본 리포트는 2022년, 2023년 및 2024년 재무상태표, 손익계산서를 바탕으로 작성되었습니다.")

**[업체 개요]**
- 업체번호(가칭): ${formData.businessNumber || '미입력'}
- 업종: ${formData.industry || '미입력'}
- 설립일자: ${formData.foundationDate || '미입력'}
- 주요제품: ${formData.majorProducts || '미입력'}

**[분석 목표]**
이 기업에 대한 보증 지원 또는 대출 심사를 진행한다고 가정하고, 다음 5가지 핵심 영역을 분석해 주세요.

1. **재무제표 리뷰** (**400자 이내**)
   - **[성장성]**, **[수익성]**, **[안정성]** 세 가지 소주제로 문단을 나누어 기술하세요.
   - 개별 재무 지표들을 단순 나열식으로 설명하지 말고, 세 가지 소주제별로 종합적으로 설명하세요.
    - **[절대 주의]**: 소주제 제목(**[성장성]** 등) 뒤에 **절대 줄바꿈 하지 마세요.** **[성장성]** 내용을 바로 이어서 한 문단으로 작성하세요. 
    - **[형식 금지]**: 소주제에 '###' 등 Markdown 헤더 문법을 **절대 사용하지 마세요.** 그냥 **Bold** 처리만 하세요. (예: **[성장성]** 매출액이 전년 대비...)
    - 각 소주제는 문단으로만 구분되고, 문단 사이에 점선을 만들지 마세요.

2. **재무적 리스크 진단** (**분량 엄수: 600자 이내**)
   - "주요 재무적 리스크는 다음과 같습니다"와 같은 도입부 문장을 절대 사용하지 마세요. 바로 본론부터 작성하세요.
   - 개별 리스크 항목을 나열식(Bullet points)으로 작성하지 말고, **하나의 흐름을 가진 줄글(Narrative/Essay style)**로 작성하세요.
   - 분식의 의심이 가는 부분이 있다면 그 부분은 반드시 찾아내서 짚어줘야 합니다.
   - 여러 리스크 요인을 자연스럽게 연결하여 기술하되, 내용이 길어질 경우 적절히 문단을 나누어 가독성을 높이세요.

3. **기업의 긍정적 측면** (**분량 엄수: 600자 이내**)
   - "이 기업의 긍정적 측면은 다음과 같습니다"와 같은 도입부 문장을 절대 사용하지 마세요. 바로 본론부터 작성하세요.
   - 긍정적 요소들을 나열식(Bullet points)으로 작성하지 말고, **하나의 흐름을 가진 줄글(Narrative/Essay style)**로 작성하세요.
   - 여러 강점을 자연스럽게 연결하여 기업의 잠재력을 종합적으로 서술하되, 내용이 길어질 경우 적절히 문단을 나누어 작성하세요.

4. **현장 실사 시 중점 확인 사항** (**분량 엄수: 300자 이내**)
   - "현장 실사 시 다음 사항을 중점적으로 확인해야 합니다"와 같은 도입부 문장을 절대 사용하지 마세요. 바로 확인 사항부터 나열하세요.
   - 현장 방문 시 반드시 확인해야 할 포인트를 **최소 3개 ~ 최대 5개** 범위 내에서 리스트업 하세요. (원문자 번호 ①, ②, ③ 사용)
   - 필수 질문이나 확인 서류를 명시하세요.

5. **종합 의견** (**분량 엄수: 300자 이내**)
   - 앞선 분석 내용을 바탕으로 대출 승인/반려 여부에 대한 최종 의견을 제시하지는 말고, 심사자가 판단할 수 있는 **종합적인 요약**을 제공하세요.

**[리포트 작성 지침 - 매우 중요]**
- **시작**: "1. 재무제표 리뷰"로 시작하되, 바로 아래에 위에서 언급한 **분석 대상 데이터 검증 문구**를 한 줄 작성하고 본문을 시작하세요.
- **[절대 금지]**: "기업 진단 리포트 (업체번호: ...)" 와 같은 **문서 제목이나 업체 정보를 최상단에 작성하지 마세요.** 이미 상단 헤더에 표시되어 있습니다.
- **문체(Tone & Manner)**: **"~습니다", "~됩니다", "~것으로 판단됩니다"**와 같은 **정중하고 분석적인 보고서 어조**를 일관되게 사용하세요.
    - **절대 금지**: 반말("~다", "~야", "~임"), 구어체("...하네요", "...같아요"), 불명확한 추측성 표현.
    - **일관성**: 전체 리포트의 문체가 통일되어야 합니다.
- **분량 준수**: 각 항목별로 제시된 글자 수 제한(**300자, 600자**)을 **반드시 준수**하세요. 내용이 길어지면 **핵심 내용 위주로 과감하게 요약**하세요.
- **양식**: **[성장성]** 내용... 형태로 줄바꿈 없이 작성하는 것을 철저히 지키세요.
- **말투**: 냉철하고 객관적인 전문 심사역의 톤을 유지하세요.
`;

                    if (selectedModel === 'groq') {
                        // ========== Groq Vision (OpenAI Compatible) ==========
                        // [수정] Fallback 제거, Maverick 모델 없을 시 에러 발생 유도
                        const groqModelName = groqModelId;

                        if (!groqModelName) {
                            throw new Error('Llama 4 Maverick 모델을 찾을 수 없습니다. Groq API Key를 확인하거나, 아직 해당 모델 접근 권한이 없을 수 있습니다.');
                        }

                        // [수정] 모델명 포함하여 상태 업데이트
                        setAnalysisStatus(`${groqModelName} 모델이 리포트 작성 중...`);

                        // 이미지를 Data URL로 변환하여 메시지 구성 (다중 이미지 지원)
                        const content = [
                            { type: "text", text: promptText },
                            ...fileParts.map(part => ({
                                type: "image_url",
                                image_url: { url: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}` }
                            }))
                        ];

                        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${groqApiKey}`
                            },
                            body: JSON.stringify({
                                model: groqModelName,
                                messages: [
                                    {
                                        role: "user",
                                        content: content
                                    }
                                ],
                                temperature: 0.2,
                                max_tokens: 4096,
                                top_p: 0.9
                            })
                        });

                        const data = await response.json();

                        if (data.choices && data.choices[0] && data.choices[0].message) {
                            setAiResponse(data.choices[0].message.content);
                            setViewMode('report');
                            window.scrollTo(0, 0);
                        } else {
                            console.error('Groq API Error:', data);
                            if (data.error) {
                                throw new Error(`[Groq] ${data.error.message}`);
                            }
                            throw new Error('문서 분석에 실패했습니다.');
                        }

                    } else {
                        // ========== Google Gemini (기존 로직) ==========
                        // [수정] 모델 동적 탐색 (Total Solution 로직 적용 - 안정성 확보)
                        const listResp = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`);
                        const listData = await listResp.json();
                        if (listData.error) throw new Error(listData.error.message);

                        const generativeModels = listData.models.filter(m => m.supportedGenerationMethods.includes('generateContent') && !m.name.includes('embedding') && !m.name.includes('aqa'));

                        // [수정] 2.5 모델을 최우선으로 찾고, 없으면 1.5나 최신 모델을 선택
                        let bestModel;
                        if (selectedModel === 'gemini-2.5-flash') {
                            bestModel = generativeModels.find(m => m.name.includes('gemini-2.5-flash'));
                        } else {
                            // gemini-3-flash (기본값)
                            bestModel = generativeModels.find(m => m.name.includes('gemini-3-flash-preview'));
                        }

                        if (!bestModel) throw new Error(`${selectedModel} 모델을 찾을 수 없습니다. API Key 권한이나 모델 사용 가능 여부를 확인해주세요.`);

                        // [수정] UI 표기도 실제 이름을 그대로 사용 (강제 변환 로직 삭제)
                        let realName = bestModel.name.split('/')[1];
                        setAnalysisStatus(`${realName} 모델이 리포트 작성 중...`);

                        // Gemini API 요청 구성 (다중 이미지 지원)
                        const contentsParts = [{ text: promptText }, ...fileParts];

                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/${bestModel.name}:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: [{ parts: contentsParts }] })
                        });

                        const data = await response.json();

                        if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                            setAiResponse(data.candidates[0].content.parts[0].text);
                            setViewMode('report');
                            window.scrollTo(0, 0);
                        } else {
                            console.error('API Error:', data);
                            if (data.error && data.error.code === 429) {
                                throw new Error("구글 AI API 사용량이 초과되었습니다. 잠시 후 다시 시도해 주세요.");
                            }
                            throw new Error(`분석 결과를 받아오지 못했습니다. 상세: ${data.error ? data.error.message : '알 수 없음'}`);
                        }
                    }

                } catch (error) {
                    const msg = error.message.includes('429') || error.message.includes('quota') || error.message.includes('초과')
                        ? "구글 AI API 사용량이 초과되었습니다. 잠시 후 다시 시도해 주세요."
                        : `오류 발생: ${error.message}`;
                    alert(msg);
                    console.error(error);
                } finally {
                    setIsAnalyzing(false);
                    setAnalysisStatus('');
                }
            };

            const ReportView = () => (
                <div className="max-w-4xl mx-auto my-8 print:m-0 print:p-0 animate-in fade-in slide-in-from-bottom-4 duration-700">
                    <div className="bg-white p-12 print:p-0 shadow-xl border border-slate-200 rounded-sm print-container report-view">
                        <div className="border-b-4 border-slate-900 pb-4 mb-6">
                            <h1 className="text-3xl font-black text-slate-900 tracking-tight">재무제표 AI 진단 리포트</h1>
                            <p className="text-sm text-slate-500 font-bold mt-2">Financial Analysis by Seoul Credit Guarantee Foundation</p>
                        </div>

                        {/* 기본정보 요약 */}
                        <div className="mb-6 report-info-container bg-slate-50 rounded-lg border border-slate-200 p-4">
                            <h3 className="text-xs font-bold text-slate-400 uppercase mb-3 tracking-wider border-b border-slate-200 pb-1 flex items-center">
                                기업 개요
                            </h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 report-info-grid">
                                <div className="report-info-item"><span className="text-xs text-slate-500 block report-info-label">업체번호</span><span className="text-sm font-black text-slate-800 report-info-value">{formData.businessNumber || "-"}</span></div>
                                <div className="report-info-item"><span className="text-xs text-slate-500 block report-info-label">설립일자</span><span className="text-sm font-black text-slate-800 report-info-value">{formData.foundationDate || "-"}</span></div>
                                <div className="report-info-item"><span className="text-xs text-slate-500 block report-info-label">업종</span><span className="text-sm font-black text-slate-800 report-info-value">{formData.industry || "-"}</span></div>
                                <div className="report-info-item"><span className="text-xs text-slate-500 block report-info-label">주요제품</span><span className="text-sm font-black text-slate-800 report-info-value">{formData.majorProducts || "-"}</span></div>
                            </div>
                        </div>

                        {/* AI 본문 */}
                        <div className="space-y-4 text-slate-700 leading-relaxed text-sm md:text-base">
                            {formatText(aiResponse)}
                        </div>

                        <div className="mt-8 pt-6 border-t flex justify-center gap-4 no-print">
                            <button onClick={() => setViewMode('form')} className="px-8 py-3 bg-slate-800 text-white rounded-full font-black hover:bg-slate-700 flex items-center gap-2"><Icon name="rotate-ccw" size={18} /> 다시 진단하기</button>
                            <button onClick={() => window.print()} className="px-8 py-3 border-2 border-slate-800 text-slate-800 rounded-full font-black hover:bg-slate-50 transition-all">
                                리포트 인쇄
                            </button>
                        </div>
                    </div>
                </div>
            );

            if (viewMode === 'report') return <div className="min-h-screen py-8 px-4 bg-slate-100 print:p-0 print:m-0 print:bg-white"><ReportView /></div>;

            return (
                <div className="min-h-screen py-8 px-4 relative">
                    <div className="max-w-5xl mx-auto mb-4 no-print flex justify-end items-center gap-2">
                        <button
                            onClick={() => setShowApiConfig(!showApiConfig)}
                            className={`text-xs px-3 py-1.5 rounded-full flex items-center gap-2 shadow-lg transition-all ${showApiConfig ? 'bg-emerald-500 text-white' : 'bg-slate-700 text-white hover:bg-slate-600'}`}
                        >
                            <Icon name="shield-check" size={14} className={showApiConfig ? 'text-white' : 'text-emerald-400'} />
                            <span className="font-bold">Safe Connect Mode</span>
                            {(apiKey || groqApiKey) &&
                                <span className="bg-emerald-500 text-white text-[10px] px-1.5 py-0.5 rounded-full font-bold">ON</span>
                            }
                        </button>
                    </div>

                    {showApiConfig && (
                        <div className="max-w-5xl mx-auto mb-4 no-print bg-slate-800 text-white rounded-lg p-4 shadow-xl border border-slate-700">
                            <div className="flex items-center gap-2 mb-3 pb-2 border-b border-slate-600">
                                <Icon name="shield-check" size={16} className="text-emerald-400" />
                                <span className="font-black text-sm">API Key 및 분석 모델 설정</span>
                            </div>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div className="space-y-1">
                                    <label className="text-xs font-bold text-blue-300">Google API Key</label>
                                    <input
                                        type="password"
                                        placeholder="Google API Key 입력"
                                        className="w-full bg-slate-900 border border-slate-600 rounded p-2 text-xs focus:border-blue-400 focus:outline-none"
                                        value={apiKey}
                                        onChange={(e) => setApiKey(e.target.value)}
                                    />
                                    <p className="text-[10px] text-slate-400">Gemini 모델(Vision) 사용 시 필요</p>
                                </div>
                                <div className="space-y-1">
                                    <label className="text-xs font-bold text-orange-300">Groq API Key</label>
                                    <input
                                        type="password"
                                        placeholder="Groq API Key 입력"
                                        className="w-full bg-slate-900 border border-slate-600 rounded p-2 text-xs focus:border-orange-400 focus:outline-none"
                                        value={groqApiKey}
                                        onChange={(e) => setGroqApiKey(e.target.value)}
                                    />
                                    <p className="text-[10px] text-slate-400">Groq 모델(Vision) 사용 시 필요</p>
                                </div>
                                <div className="space-y-1">
                                    <label className="text-xs font-bold text-emerald-300">분석 모델 선택</label>
                                    <select
                                        className="w-full bg-slate-900 border border-slate-600 rounded p-2 text-xs focus:border-emerald-400 focus:outline-none"
                                        value={selectedModel}
                                        onChange={(e) => setSelectedModel(e.target.value)}
                                    >
                                        <option value="gemini-3-flash">🟦 Gemini 3.0 Flash Preview (Google)</option>
                                        <option value="gemini-2.5-flash">🟦 Gemini 2.5 Flash (Google)</option>
                                        <option value="groq">🟧 {groqModelId ? `${groqModelId} (Groq)` : 'Llama 4 Maverick (Groq)'}</option>
                                    </select>
                                    <p className="text-[10px] text-slate-400">
                                        {selectedModel.includes('gemini') ? '✅ Google Gemini API 사용' : '✅ Groq API 사용 (빠른 응답)'}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="max-w-5xl mx-auto bg-white shadow-2xl border border-slate-200 overflow-hidden print-container rounded-sm">
                        <div className="p-10 border-b border-slate-100 bg-white relative">
                            <div className="flex justify-between items-start">
                                <div>
                                    <div className="flex items-center gap-2 mb-2">
                                        <span className="text-xs font-bold text-slate-400 tracking-tighter uppercase italic">Seoul Credit Guarantee Foundation</span>
                                    </div>
                                    <h1 className="text-4xl font-black text-slate-900 tracking-tight leading-none mb-2">재무제표 기반 AI 기업 진단</h1>
                                    <p className="text-sm text-slate-500 font-medium">재무제표 분석을 통한 리스크 점검 및 심사 포인트 도출</p>
                                </div>
                                <div className="text-right"><p className="text-xl font-black text-[#0055A5] leading-tight mb-1">내일을 꿈꾸는 사장님께</p><p className="text-sm font-bold text-slate-400">서울신용보증재단 용산종합지원센터</p></div>
                            </div>
                        </div>

                        <div className="p-10 space-y-12">
                            <section>
                                <div className="flex items-center gap-2 mb-4">
                                    <div className="w-1.5 h-6 bg-[#0055A5]"></div>
                                    <h2 className="text-xl font-black text-slate-800 uppercase tracking-tight">1. 기업 개요</h2>
                                </div>
                                <div className="info-grid grid grid-cols-1 md:grid-cols-2 gap-y-5 gap-x-8">
                                    <div className="space-y-1.5"><label className="text-sm font-black text-slate-500 ml-1">업체번호</label><input type="text" placeholder="예: 12345" className="w-full p-3 bg-slate-50 border border-slate-200 rounded-sm outline-none text-base font-bold" value={formData.businessNumber} onChange={(e) => setFormData({ ...formData, businessNumber: e.target.value })} /></div>
                                    <div className="space-y-1.5"><label className="text-sm font-black text-slate-500 ml-1">설립일자</label><input type="date" className="w-full p-3 bg-slate-50 border border-slate-200 rounded-sm outline-none text-base font-bold" value={formData.foundationDate} onChange={(e) => setFormData({ ...formData, foundationDate: e.target.value })} /></div>
                                    <div className="space-y-1.5"><label className="text-sm font-black text-slate-500 ml-1">업종</label><input type="text" placeholder="예: 한식 음식점" className="w-full p-3 bg-slate-50 border border-slate-200 rounded-sm outline-none text-base font-bold" value={formData.industry} onChange={(e) => setFormData({ ...formData, industry: e.target.value })} /></div>
                                    <div className="space-y-1.5"><label className="text-sm font-black text-slate-500 ml-1">주요제품(상품)</label><input type="text" placeholder="예: 김치찌개, 된장찌개" className="w-full p-3 bg-slate-50 border border-slate-200 rounded-sm outline-none text-base font-bold" value={formData.majorProducts} onChange={(e) => setFormData({ ...formData, majorProducts: e.target.value })} /></div>
                                </div>
                            </section>

                            <section>
                                <div className="flex items-center gap-2 mb-4">
                                    <div className="w-1.5 h-6 bg-[#0055A5]"></div>
                                    <h2 className="text-xl font-black text-slate-800 uppercase tracking-tight">2. 재무제표 업로드</h2>
                                </div>
                                <div className="bg-slate-50 border-2 border-dashed border-slate-300 rounded-lg p-8 text-center hover:bg-slate-100 transition-colors relative">
                                    <input
                                        type="file"
                                        accept="image/*,application/pdf"
                                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                        onChange={handleFileChange}
                                    />
                                    {formData.financialFile ? (
                                        <div className="flex flex-col items-center justify-center py-2">
                                            <Icon name="file-text" size={32} className="text-emerald-500 mb-2" />
                                            <p className="text-emerald-600 font-bold text-sm mb-1">✅ 파일 선택됨</p>
                                            <span className="text-xs font-bold text-slate-500 text-center px-4 break-all max-w-sm">{formData.financialFile.name}</span>
                                        </div>
                                    ) : (
                                        <div className="flex flex-col items-center gap-3">
                                            <Icon name="upload-cloud" size={48} className="text-slate-400" />
                                            <p className="text-slate-600 font-bold text-lg">재무제표 파일(PDF, 이미지)을 이곳에 드래그하거나 클릭하여 업로드하세요</p>
                                            <p className="text-slate-400 text-sm">지원 형식: PDF, JPG, PNG</p>
                                        </div>
                                    )}
                                </div>
                                <p className="text-xs text-slate-400 mt-2 ml-1">※ 개인정보보호를 위해 업체명, 주민번호 등이 마스킹된 파일을 권장합니다.</p>
                            </section>

                            <div className="flex justify-between items-center pt-10 border-t border-slate-200 no-print">
                                <button onClick={() => { setFormData({ businessNumber: '', industry: '', foundationDate: '', majorProducts: '', financialFile: null }); setFilePreview(null); }} className="flex items-center gap-2 text-slate-400 hover:text-red-500 font-black text-sm transition-colors"><Icon name="rotate-ccw" size={16} /> 초기화</button>
                                <button onClick={runAnalysis} disabled={isAnalyzing} className={`flex items-center gap-3 px-8 py-4 bg-emerald-600 text-white rounded-sm font-black shadow-xl hover:bg-emerald-700 transition-all text-lg ${isAnalyzing ? 'opacity-50' : ''}`}><Icon name={isAnalyzing ? "loader-2" : "search"} size={22} className={isAnalyzing ? "animate-spin" : ""} />{isAnalyzing ? analysisStatus : "AI 진단 시작"}</button>
                            </div>
                        </div>
                    </div>
                </div >
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>
